/** <<Typesetter> function dependency: R2>.init **/

troikaDefine(
function(){return (
function R2(c,e){const i=/[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,r="[^\\S\\u00A0]",n=new RegExp(`${r}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);function a({text:y,lang:A,fonts:B,style:x,weight:S,preResolvedFonts:E,unicodeFontsURL:T},w){const b=({chars:R,fonts:F})=>{let D,k;const J=[];for(let O=0;O<R.length;O++)R[O]!==k?(k=R[O],J.push(D={start:O,end:O,fontObj:F[R[O]]})):D.end=O;w(J)};E?b(E):c(y,b,{lang:A,fonts:B,style:x,weight:S,unicodeFontsURL:T})}function l({text:y="",font:A,lang:B,sdfGlyphSize:x=64,fontSize:S=400,fontWeight:E=1,fontStyle:T="normal",letterSpacing:w=0,lineHeight:b="normal",maxWidth:R=1/0,direction:F,textAlign:D="left",textIndent:k=0,whiteSpace:J="normal",overflowWrap:O="normal",anchorX:H=0,anchorY:L=0,metricsOnly:q=!1,unicodeFontsURL:W,preResolvedFonts:se=null,includeCaretPositions:Y=!1,chunkedBoundsSize:K=8192,colorRanges:j=null},I){const G=m(),z={fontLoad:0,typesetting:0};y.indexOf("\r")>-1&&(console.info("Typesetter: got text with \\r chars; normalizing to \\n"),y=y.replace(/\r\n/g,`
`).replace(/\r/g,`
`)),S=+S,w=+w,R=+R,b=b||"normal",k=+k,a({text:y,lang:B,style:T,weight:E,fonts:typeof A=="string"?[{src:A}]:A,unicodeFontsURL:W,preResolvedFonts:se},X=>{z.fontLoad=m()-G;const Q=isFinite(R);let te=null,ee=null,ie=null,fe=null,_e=null,ae=null,oe=null,Te=null,De=0,me=0,ye=J!=="nowrap";const we=new Map,ue=m();let Ce=k,ge=0,re=new g;const be=[re];X.forEach(xe=>{const{fontObj:Me}=xe,{ascender:Pe,descender:ke,unitsPerEm:et,lineGap:ut,capHeight:je,xHeight:He}=Me;let Fe=we.get(Me);if(!Fe){const Ie=S/et,Ye=b==="normal"?(Pe-ke+ut)*Ie:b*S,rn=(Ye-(Pe-ke)*Ie)/2,Ze=Math.min(Ye,(Pe-ke)*Ie),Ne=(Pe+ke)/2*Ie+Ze/2;Fe={index:we.size,src:Me.src,fontObj:Me,fontSizeMult:Ie,unitsPerEm:et,ascender:Pe*Ie,descender:ke*Ie,capHeight:je*Ie,xHeight:He*Ie,lineHeight:Ye,baseline:-rn-Pe*Ie,caretTop:Ne,caretBottom:Ne-Ze},we.set(Me,Fe)}const{fontSizeMult:ct}=Fe,rt=y.slice(xe.start,xe.end+1);let Qt,tt;Me.forEachGlyph(rt,S,w,(Ie,Ye,rn,Ze)=>{Ye+=ge,Ze+=xe.start,Qt=Ye,tt=Ie;const Ne=y.charAt(Ze),dt=Ie.advanceWidth*ct,st=re.count;let Oe;if("isEmpty"in Ie||(Ie.isWhitespace=!!Ne&&new RegExp(r).test(Ne),Ie.canBreakAfter=!!Ne&&n.test(Ne),Ie.isEmpty=Ie.xMin===Ie.xMax||Ie.yMin===Ie.yMax||i.test(Ne)),!Ie.isWhitespace&&!Ie.isEmpty&&me++,ye&&Q&&!Ie.isWhitespace&&Ye+dt+Ce>R&&st){if(re.glyphAt(st-1).glyphObj.canBreakAfter)Oe=new g,Ce=-Ye;else for(let Rt=st;Rt--;)if(Rt===0&&O==="break-word"){Oe=new g,Ce=-Ye;break}else if(re.glyphAt(Rt).glyphObj.canBreakAfter){Oe=re.splitAt(Rt+1);const Dt=Oe.glyphAt(0).x;Ce-=Dt;for(let yt=Oe.count;yt--;)Oe.glyphAt(yt).x-=Dt;break}Oe&&(re.isSoftWrapped=!0,re=Oe,be.push(re),De=R)}let nt=re.glyphAt(re.count);nt.glyphObj=Ie,nt.x=Ye+Ce,nt.y=rn,nt.width=dt,nt.charIndex=Ze,nt.fontData=Fe,Ne===`
`&&(re=new g,be.push(re),Ce=-(Ye+dt+w*S)+k)}),ge=Qt+tt.advanceWidth*ct+w*S});let pe=0;be.forEach(xe=>{let Me=!0;for(let Pe=xe.count;Pe--;){const ke=xe.glyphAt(Pe);Me&&!ke.glyphObj.isWhitespace&&(xe.width=ke.x+ke.width,xe.width>De&&(De=xe.width),Me=!1);let{lineHeight:et,capHeight:ut,xHeight:je,baseline:He}=ke.fontData;et>xe.lineHeight&&(xe.lineHeight=et);const Fe=He-xe.baseline;Fe<0&&(xe.baseline+=Fe,xe.cap+=Fe,xe.ex+=Fe),xe.cap=Math.max(xe.cap,xe.baseline+ut),xe.ex=Math.max(xe.ex,xe.baseline+je)}xe.baseline-=pe,xe.cap-=pe,xe.ex-=pe,pe+=xe.lineHeight});let Ae=0,de=0;if(H&&(typeof H=="number"?Ae=-H:typeof H=="string"&&(Ae=-De*(H==="left"?0:H==="center"?.5:H==="right"?1:f(H)))),L&&(typeof L=="number"?de=-L:typeof L=="string"&&(de=L==="top"?0:L==="top-baseline"?-be[0].baseline:L==="top-cap"?-be[0].cap:L==="top-ex"?-be[0].ex:L==="middle"?pe/2:L==="bottom"?pe:L==="bottom-baseline"?-be[be.length-1].baseline:f(L)*pe)),!q){const xe=e.getEmbeddingLevels(y,F);te=new Uint16Array(me),ee=new Uint8Array(me),ie=new Float32Array(me*2),fe={},oe=[1/0,1/0,-1/0,-1/0],Te=[],Y&&(ae=new Float32Array(y.length*4)),j&&(_e=new Uint8Array(me*3));let Me=0,Pe=-1,ke=-1,et,ut;if(be.forEach((je,He)=>{let{count:Fe,width:ct}=je;if(Fe>0){let rt=0;for(let Ze=Fe;Ze--&&je.glyphAt(Ze).glyphObj.isWhitespace;)rt++;let Qt=0,tt=0;if(D==="center")Qt=(De-ct)/2;else if(D==="right")Qt=De-ct;else if(D==="justify"&&je.isSoftWrapped){let Ze=0;for(let Ne=Fe-rt;Ne--;)je.glyphAt(Ne).glyphObj.isWhitespace&&Ze++;tt=(De-ct)/Ze}if(tt||Qt){let Ze=0;for(let Ne=0;Ne<Fe;Ne++){let dt=je.glyphAt(Ne);const st=dt.glyphObj;dt.x+=Qt+Ze,tt!==0&&st.isWhitespace&&Ne<Fe-rt&&(Ze+=tt,dt.width+=tt)}}const Ie=e.getReorderSegments(y,xe,je.glyphAt(0).charIndex,je.glyphAt(je.count-1).charIndex);for(let Ze=0;Ze<Ie.length;Ze++){const[Ne,dt]=Ie[Ze];let st=1/0,Oe=-1/0;for(let nt=0;nt<Fe;nt++)if(je.glyphAt(nt).charIndex>=Ne){let Rt=nt,Dt=nt;for(;Dt<Fe;Dt++){let yt=je.glyphAt(Dt);if(yt.charIndex>dt)break;Dt<Fe-rt&&(st=Math.min(st,yt.x),Oe=Math.max(Oe,yt.x+yt.width))}for(let yt=Rt;yt<Dt;yt++){const gr=je.glyphAt(yt);gr.x=Oe-(gr.x+gr.width-st)}break}}let Ye;const rn=Ze=>Ye=Ze;for(let Ze=0;Ze<Fe;Ze++){const Ne=je.glyphAt(Ze);Ye=Ne.glyphObj;const dt=Ye.index,st=xe.levels[Ne.charIndex]&1;if(st){const Oe=e.getMirroredCharacter(y[Ne.charIndex]);Oe&&Ne.fontData.fontObj.forEachGlyph(Oe,0,0,rn)}if(Y){const{charIndex:Oe,fontData:nt}=Ne,Rt=Ne.x+Ae,Dt=Ne.x+Ne.width+Ae;ae[Oe*4]=st?Dt:Rt,ae[Oe*4+1]=st?Rt:Dt,ae[Oe*4+2]=je.baseline+nt.caretBottom+de,ae[Oe*4+3]=je.baseline+nt.caretTop+de;const yt=Oe-Pe;yt>1&&h(ae,Pe,yt),Pe=Oe}if(j){const{charIndex:Oe}=Ne;for(;Oe>ke;)ke++,j.hasOwnProperty(ke)&&(ut=j[ke])}if(!Ye.isWhitespace&&!Ye.isEmpty){const Oe=Me++,{fontSizeMult:nt,src:Rt,index:Dt}=Ne.fontData,yt=fe[Rt]||(fe[Rt]={});yt[dt]||(yt[dt]={path:Ye.path,pathBounds:[Ye.xMin,Ye.yMin,Ye.xMax,Ye.yMax]});const gr=Ne.x+Ae,Yr=Ne.y+je.baseline+de;ie[Oe*2]=gr,ie[Oe*2+1]=Yr;const vr=gr+Ye.xMin*nt,nn=Yr+Ye.yMin*nt,_r=gr+Ye.xMax*nt,Zr=Yr+Ye.yMax*nt;vr<oe[0]&&(oe[0]=vr),nn<oe[1]&&(oe[1]=nn),_r>oe[2]&&(oe[2]=_r),Zr>oe[3]&&(oe[3]=Zr),Oe%K===0&&(et={start:Oe,end:Oe,rect:[1/0,1/0,-1/0,-1/0]},Te.push(et)),et.end++;const Ht=et.rect;if(vr<Ht[0]&&(Ht[0]=vr),nn<Ht[1]&&(Ht[1]=nn),_r>Ht[2]&&(Ht[2]=_r),Zr>Ht[3]&&(Ht[3]=Zr),te[Oe]=dt,ee[Oe]=Dt,j){const yn=Oe*3;_e[yn]=ut>>16&255,_e[yn+1]=ut>>8&255,_e[yn+2]=ut&255}}}}}),ae){const je=y.length-Pe;je>1&&h(ae,Pe,je)}}const We=[];we.forEach(({index:xe,src:Me,unitsPerEm:Pe,ascender:ke,descender:et,lineHeight:ut,capHeight:je,xHeight:He})=>{We[xe]={src:Me,unitsPerEm:Pe,ascender:ke,descender:et,lineHeight:ut,capHeight:je,xHeight:He}}),z.typesetting=m()-ue,I({glyphIds:te,glyphFontIndices:ee,glyphPositions:ie,glyphData:fe,fontData:We,caretPositions:ae,glyphColors:_e,chunkedBounds:Te,fontSize:S,topBaseline:de+be[0].baseline,blockBounds:[Ae,de-pe,Ae+De,de],visibleBounds:oe,timings:z})})}function u(y,A){l({...y,metricsOnly:!0},B=>{const[x,S,E,T]=B.blockBounds;A({width:E-x,height:T-S})})}function f(y){let A=y.match(/^([\d.]+)%$/),B=A?parseFloat(A[1]):NaN;return isNaN(B)?0:B/100}function h(y,A,B){const x=y[A*4],S=y[A*4+1],E=y[A*4+2],T=y[A*4+3],w=(S-x)/B;for(let b=0;b<B;b++){const R=(A+b)*4;y[R]=x+w*b,y[R+1]=x+w*(b+1),y[R+2]=E,y[R+3]=T}}function m(){return(self.performance||Date).now()}function g(){this.data=[]}const _=["glyphObj","x","y","width","charIndex","fontData"];return g.prototype={width:0,lineHeight:0,baseline:0,cap:0,ex:0,isSoftWrapped:!1,get count(){return Math.ceil(this.data.length/_.length)},glyphAt(y){let A=g.flyweight;return A.data=this.data,A.index=y,A},splitAt(y){let A=new g;return A.data=this.data.splice(y*_.length),A}},g.flyweight=_.reduce((y,A,B,x)=>(Object.defineProperty(y,A,{get(){return this.data[this.index*_.length+B]},set(S){this.data[this.index*_.length+B]=S}}),y),{data:null,index:0}),{typeset:l,measure:u}}
)}
)