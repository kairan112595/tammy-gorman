/** <<FontResolver> function dependency: F2>.init **/

troikaDefine(
function(){return (
function F2(c,e){const t=Object.create(null),i=Object.create(null);function r(a,l){const u=f=>{console.error(`Failure loading font ${a}`,f)};try{const f=new XMLHttpRequest;f.open("get",a,!0),f.responseType="arraybuffer",f.onload=function(){if(f.status>=400)u(new Error(f.statusText));else if(f.status>0)try{const h=c(f.response);h.src=a,l(h)}catch(h){u(h)}},f.onerror=u,f.send()}catch(f){u(f)}}function n(a,l){let u=t[a];u?l(u):i[a]?i[a].push(l):(i[a]=[l],r(a,f=>{f.src=a,t[a]=f,i[a].forEach(h=>h(f)),delete i[a]}))}return function(a,l,{lang:u,fonts:f=[],style:h="normal",weight:m="normal",unicodeFontsURL:g}={}){const _=new Uint8Array(a.length),y=[];a.length||S();const A=new Map,B=[];if(h!=="italic"&&(h="normal"),typeof m!="number"&&(m=m==="bold"?700:400),f&&!Array.isArray(f)&&(f=[f]),f=f.slice().filter(T=>!T.lang||T.lang.test(u)).reverse(),f.length){let R=0;(function F(D=0){for(let k=D,J=a.length;k<J;k++){const O=a.codePointAt(k);if(R===1&&y[_[k-1]].supportsCodePoint(O)||/\s/.test(a[k]))_[k]=_[k-1],R===2&&(B[B.length-1][1]=k);else for(let H=_[k],L=f.length;H<=L;H++)if(H===L){const q=R===2?B[B.length-1]:B[B.length]=[k,k];q[1]=k,R=2}else{_[k]=H;const{src:q,unicodeRange:W}=f[H];if(!W||E(O,W)){const se=t[q];if(!se){n(q,()=>{F(k)});return}if(se.supportsCodePoint(O)){let Y=A.get(se);typeof Y!="number"&&(Y=y.length,y.push(se),A.set(se,Y)),_[k]=Y,R=1;break}}}O>65535&&k+1<J&&(_[k+1]=_[k],k++,R===2&&(B[B.length-1][1]=k))}x()})()}else B.push([0,a.length-1]),x();function x(){if(B.length){const T=B.map(w=>a.substring(w[0],w[1]+1)).join(`
`);e.getFontsForString(T,{lang:u||void 0,style:h,weight:m,dataUrl:g}).then(({fontUrls:w,chars:b})=>{const R=y.length;let F=0;B.forEach(k=>{for(let J=0,O=k[1]-k[0];J<=O;J++)_[k[0]+J]=b[F++]+R;F++});let D=0;w.forEach((k,J)=>{n(k,O=>{y[J+R]=O,++D===w.length&&S()})})})}else S()}function S(){l({chars:_,fonts:y})}function E(T,w){for(let b=0;b<w.length;b++){const[R,F=R]=w[b];if(R<=T&&T<=F)return!0}return!1}}}
)}
)